package kevin.module.modules.exploit

import kevin.event.*
import kevin.module.ListValue
import kevin.module.Module
import kevin.module.ModuleCategory
import kevin.utils.BlockUtils
import kevin.utils.MovementUtils
import kevin.utils.TickTimer
import net.minecraft.block.BlockAir
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos

class Phase : Module("Phase", "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT) {

    private val modeValue = ListValue("Mode", arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex"), "Vanilla")

    private val tickTimer = TickTimer()

    private var mineplexClip = false
    private val mineplexTickTimer = TickTimer()

    @EventTarget
    fun onUpdate(event: UpdateEvent) {

        //if (event.eventState == UpdateState.OnUpdate) return

        val isInsideBlock: Boolean =
            BlockUtils.collideBlockIntersects(mc.thePlayer.entityBoundingBox) { block ->
                (block)!is BlockAir
            }
        if (isInsideBlock && !modeValue.get().equals("Mineplex",true)) {
            mc.thePlayer.noClip = true
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.onGround = false
        }
        val netHandlerPlayClient = mc.netHandler
        when (modeValue.get().toLowerCase()) {
            "vanilla" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer
                        .isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)
                ) return
                netHandlerPlayClient.addToSendQueue(
                    C03PacketPlayer.C04PacketPlayerPosition(
                        mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true
                    )
                )
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(0.5, .0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(
                    C03PacketPlayer.C04PacketPlayerPosition(
                        mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true
                    )
                )
                netHandlerPlayClient.addToSendQueue(
                    C03PacketPlayer.C04PacketPlayerPosition(
                        mc.thePlayer.posX,
                        mc.thePlayer.posY + 0.2,
                        mc.thePlayer.posZ,
                        true
                    )
                )
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(0.5, .0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(
                    C03PacketPlayer.C04PacketPlayerPosition(
                        mc.thePlayer.posX + 0.5,
                        mc.thePlayer.posY,
                        mc.thePlayer.posZ + 0.5,
                        true
                    )
                )
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val x = -Math.sin(yaw) * 0.04
                val z = Math.cos(yaw) * 0.04
                mc.thePlayer.setPosition(
                    mc.thePlayer.posX + x,
                    mc.thePlayer.posY,
                    mc.thePlayer.posZ + z
                )
                tickTimer.reset()
            }
            "skip" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer
                        .isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking())
                ) return
                val direction: Double = MovementUtils.direction
                val posX = -Math.sin(direction) * 0.3
                val posZ = Math.cos(direction) * 0.3
                var i = 0
                while (i < 3) {
                    mc.netHandler.addToSendQueue(
                        C03PacketPlayer.C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY + 0.06,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                    mc.netHandler.addToSendQueue(
                        C03PacketPlayer.C04PacketPlayerPosition(
                            mc.thePlayer.posX + posX * i,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ + posZ * i,
                            true
                        )
                    )
                    ++i
                }
                mc.thePlayer.setEntityBoundingBox(mc.thePlayer.getEntityBoundingBox().offset(posX, .0, posZ))
                mc.thePlayer.setPositionAndUpdate(
                    mc.thePlayer.posX + posX,
                    mc.thePlayer.posY,
                    mc.thePlayer.posZ + posZ
                )
                tickTimer.reset()
            }
            "spartan" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer
                        .isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking())
                ) return
                netHandlerPlayClient.addToSendQueue(
                    C03PacketPlayer.C04PacketPlayerPosition(
                        mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true
                    )
                )
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(0.5, .0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(
                    C03PacketPlayer.C04PacketPlayerPosition(
                        mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true
                    )
                )
                netHandlerPlayClient.addToSendQueue(
                    C03PacketPlayer.C04PacketPlayerPosition(
                        mc.thePlayer.posX,
                        mc.thePlayer.posY - 0.2,
                        mc.thePlayer.posZ,
                        true
                    )
                )
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(0.5, .0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(
                    C03PacketPlayer.C04PacketPlayerPosition(
                        mc.thePlayer.posX + 0.5,
                        mc.thePlayer.posY,
                        mc.thePlayer.posZ + 0.5,
                        true
                    )
                )
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val x = -Math.sin(yaw) * 0.04
                val z = Math.cos(yaw) * 0.04
                mc.thePlayer.setPosition(
                    mc.thePlayer.posX + x,
                    mc.thePlayer.posY,
                    mc.thePlayer.posZ + z
                )
                tickTimer.reset()
            }
            "clip" -> {
                if (!tickTimer.hasTimePassed(2) || !mc.thePlayer
                        .isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking())
                ) return
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val oldX: Double = mc.thePlayer.posX
                val oldZ: Double = mc.thePlayer.posZ
                var i = 1
                while (i <= 10) {
                    val x = -Math.sin(yaw) * i
                    val z = Math.cos(yaw) * i
                    if ((BlockUtils.getBlock(BlockPos(oldX + x, mc.thePlayer.posY, oldZ + z))) is BlockAir
                        && (BlockUtils.getBlock(BlockPos(oldX + x, mc.thePlayer.posY + 1, oldZ + z)))is BlockAir
                    ) {
                        mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z)
                        break
                    }
                    i++
                }
                tickTimer.reset()
            }
            "aac3.5.0" -> {
                if (!tickTimer.hasTimePassed(2) || !mc.thePlayer
                        .isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)
                ) return
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val oldX: Double = mc.thePlayer.posX
                val oldZ: Double = mc.thePlayer.posZ
                val x = -Math.sin(yaw)
                val z = Math.cos(yaw)
                mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z)
                tickTimer.reset()
            }
        }
        tickTimer.update()
    }

    @EventTarget
    fun onBlockBB(event: BlockBBEvent) {
        if (mc.thePlayer != null && BlockUtils.collideBlockIntersects(
                mc.thePlayer.entityBoundingBox
            ) { block ->
                (block)!is BlockAir
            } && event.boundingBox != null && event.boundingBox!!.maxY > mc.thePlayer
                .entityBoundingBox.minY && !modeValue.get().equals("Mineplex",true)
        ) {
            val axisAlignedBB = event.boundingBox ?: return
            event.boundingBox = (
                AxisAlignedBB(
                    axisAlignedBB.maxX,
                    mc.thePlayer.entityBoundingBox.minY,
                    axisAlignedBB.maxZ,
                    axisAlignedBB.minX,
                    axisAlignedBB.minY,
                    axisAlignedBB.minZ
                )
            )
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if ((packet)is C03PacketPlayer) {
            if (modeValue.get().equals("AAC3.5.0",true)) {
                val yaw = MovementUtils.direction
                packet.x = (packet.x - Math.sin(yaw) * 0.00000001)
                packet.z = (packet.z + Math.cos(yaw) * 0.00000001)
            }
        }
    }

    @EventTarget
    private fun onMove(event: MoveEvent) {
        if (modeValue.get().equals("mineplex",true)) {
            if (mc.thePlayer.isCollidedHorizontally) mineplexClip = true
            if (!mineplexClip) return
            mineplexTickTimer.update()
            event.x = 0.0
            event.z = 0.0
            if (mineplexTickTimer.hasTimePassed(3)) {
                mineplexTickTimer.reset()
                mineplexClip = false
            } else if (mineplexTickTimer.hasTimePassed(1)) {
                val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
                val direction: Double = MovementUtils.direction
                mc.thePlayer.setPosition(
                    mc.thePlayer.posX + -Math.sin(direction) * offset,
                    mc.thePlayer.posY,
                    mc.thePlayer.posZ + Math.cos(direction) * offset
                )
            }
        }
    }

    @EventTarget
    fun onPushOut(event: PushOutEvent) {
        event.cancelEvent()
    }

    override val tag: String
        get() = modeValue.get()
}