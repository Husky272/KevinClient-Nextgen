package kevin.module.modules.exploit;

import kevin.event.*;
import kevin.main.KevinClient;
import kevin.module.*;
import kevin.module.modules.combat.BackTrack;
import net.minecraft.network.Packet;
import net.minecraft.network.play.INetHandlerPlayClient;
import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement;
import net.minecraft.network.play.server.S01PacketJoinGame;
import net.minecraft.network.play.server.S03PacketTimeUpdate;
import net.minecraft.network.play.server.S07PacketRespawn;
import org.lwjgl.input.Keyboard;

import java.util.LinkedList;

@SuppressWarnings("unchecked")
public class ServerSidePacketDelayer extends Module {
    private final ListValue mode = new ListValue("Mode", new String[]{"Size", "SmartGrimACGhostBlock", "Time"}, "Size");
    private final TextValue ignored = new TextValue("Time mode is inactive now!", "");
    private final IntegerValue size = new IntegerValue("MaxDelaySize", 500, 0, 1200);
    private final IntegerValue time = new IntegerValue("MaxDelayTime", 1000, 0, 6000);

    private final LinkedList<PacketEvent> packets = new LinkedList<>();
    private boolean backTrackEnabled = false;
    private BackTrack backTrack = null;
    private boolean hasPlace = false;
    public ServerSidePacketDelayer() {
        super("ServerSidePacketDelayer", "Delay all server-side packets", Keyboard.KEY_NONE, ModuleCategory.EXPLOIT);
    }

    @Override
    public void onEnable() {
        if (backTrack == null) backTrack = KevinClient.moduleManager.getModule(BackTrack.class);
        if (backTrack.getState()) {
            backTrackEnabled = true;
            backTrack.setState(false);
        }
    }

    @EventTarget
    public final void onWorld(WorldEvent event) {
        clear();
    }

    @EventTarget
    public final void onPacket(PacketEvent event) {
        if (event.isCancelled()) return;
        final Packet<?> packet = event.getPacket();
        if (packet instanceof S03PacketTimeUpdate) return;
        if (packet instanceof S01PacketJoinGame || packet instanceof S07PacketRespawn) {
            clear();
            return;
        }
        if (packet.getClass().getName().startsWith("net.minecraft.network.play.server.")) {
            packets.add(event);
            event.cancelEvent();
        } else if (packet instanceof C08PacketPlayerBlockPlacement) {
            C08PacketPlayerBlockPlacement place = (C08PacketPlayerBlockPlacement) packet;
            if (place.getPlacedBlockDirection() == 255) return;
            hasPlace = true;
        }
    }

    @EventTarget
    public final void onPost(MotionEvent event) {
        if (event.getEventState() == EventState.PRE) return;
        if (packets.isEmpty()) return;
        if (mode.equal("Size") && packets.size() > size.get()) clear(this.size.get());
        if (mode.equal("SmartGrimACGhostBlock") && hasPlace) {
            hasPlace = false;
            clear(1);
        }

    }

    @Override
    public void onDisable() {
        hasPlace = false;
        clear();
        if (backTrack != null && backTrackEnabled) backTrack.setState(true);
    }

    private void clear(int size) {
        if (packets.isEmpty()) return;
        final INetHandlerPlayClient handler = mc.getNetHandler();
        while (packets.size() > size) {
            final PacketEvent event = packets.pollFirst();
            if (event == null) continue;
            try {
                final Packet<INetHandlerPlayClient> packet = (Packet<INetHandlerPlayClient>) event.getPacket();
                packet.processPacket(handler);
            } catch (Exception ignored) {}
        }
    }

    private void clear() {
        clear(0);
    }
}
