package kevin.module.modules.exploit

import kevin.event.EventTarget
import kevin.event.PacketEvent
import kevin.event.UpdateEvent
import kevin.event.WorldEvent
import kevin.module.*
import kevin.utils.PacketUtils
import kevin.utils.TimeUtils
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import java.util.*
import kotlin.concurrent.schedule

class PingSpoof : Module("PingSpoof", "Spoofs your ping to a given value.", category = ModuleCategory.EXPLOIT) {
    private val minDelayValue: IntegerValue = object : IntegerValue("MinDelay", 500, 0, 5000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val maxDelayValue = maxDelayValue.get()

            if (maxDelayValue < newValue)
                set(maxDelayValue)
        }
    }

    private val maxDelayValue: IntegerValue = object : IntegerValue("MaxDelay", 1000, 0, 5000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val minDelayValue = minDelayValue.get()

            if (minDelayValue > newValue)
                set(minDelayValue)
        }
    }
    private val c00Value = BooleanValue("C00", true)
    private val c0FValue = BooleanValue("C0F", false)
    private val c0BValue = BooleanValue("C0B", false)
    private val c13Value = BooleanValue("C13", false)
    private val c16Value = BooleanValue("C16", true)
    private val packetLossValue = FloatValue("PacketLoss", 0f, 0f, 1f)

    //private val packetQueue = hashMapOf<Packet<*>, Long>()
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()

    override fun onDisable() {
        //packetQueue.clear()
        packetBuffer.forEach {
            PacketUtils.sendPacketNoEvent(it)
        }
        packetBuffer.clear()
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        packetBuffer.clear()
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (((packet is C00PacketKeepAlive && c00Value.get()) || (packet is C0FPacketConfirmTransaction && c0FValue.get()) ||
                    (packet is C0BPacketEntityAction && c0BValue.get()) || (packet is C13PacketPlayerAbilities && c13Value.get()) ||
                    (packet is C16PacketClientStatus && c16Value.get()))) {
            event.cancelEvent()
            if (packetLossValue.get() == 0f || Math.random() > packetLossValue.get()) {
                packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                queuePacket(TimeUtils.randomDelay(minDelayValue.get(), maxDelayValue.get()))
            }
        }
        /*if (((packet)is C00PacketKeepAlive || (packet)is C16PacketClientStatus)
            && !(mc.thePlayer!!.isDead || mc.thePlayer!!.health <= 0) && !packetQueue.containsKey(packet)) {
            event.cancelEvent()

            synchronized(packetQueue) {
                packetQueue[packet] = System.currentTimeMillis() + TimeUtils.randomDelay(minDelayValue.get(), maxDelayValue.get())
            }
        }*/
    }

    private fun queuePacket(delayTime: Long) {
        Timer().schedule(delayTime) {
            if (this@PingSpoof.state&&mc.thePlayer!=null&&mc.theWorld!=null&&packetBuffer.isNotEmpty()) {
                try {
                    PacketUtils.sendPacketNoEvent(packetBuffer.poll())
                } catch (_:Exception){}
            }
        }
    }

    /*@EventTarget
    fun onUpdate(event: UpdateEvent) {
        synchronized(packetQueue) {
            packetQueue.filter {
                it.value >= System.currentTimeMillis()
            }.forEach { (packet, time) ->
                //mc.netHandler.addToSendQueue(packet)
                PacketUtils.sendPacketNoEvent(packet)
                packetQueue.remove(packet, time)
            }
        }
    }*/
}