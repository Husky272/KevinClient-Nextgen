package kevin.module.modules.exploit

import kevin.event.EventTarget
import kevin.event.PacketEvent
import kevin.event.UpdateEvent
import kevin.main.KevinClient
import kevin.module.*
import kevin.module.modules.misc.Teams
import kevin.utils.BlockUtils
import kevin.utils.ChatUtils
import kevin.utils.MovementUtils
import net.minecraft.client.entity.EntityOtherPlayerMP
import net.minecraft.init.Blocks
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C07PacketPlayerDigging
import net.minecraft.network.play.client.C0APacketAnimation
import net.minecraft.network.play.client.C0BPacketEntityAction
import net.minecraft.util.BlockPos
import net.minecraft.util.Vec3
import java.lang.Thread.sleep
import kotlin.math.abs
import kotlin.math.max
import kotlin.math.min

class TP : Module("TP","Allows you to teleport around.",category = ModuleCategory.EXPLOIT) {
    private val mode = ListValue("Mode", arrayOf("Flag","AAC"),"Flag")
    private val keepTick = IntegerValue("FlagKeepTick",40,10,60)
    private val autoBedFind = BooleanValue("AutoBedFind",false)
    private val bedFindRange = IntegerValue("BedFindRange",6,2,6)

    private val aacFlySpeedValue = FloatValue("Speed", 0.8f, 0.1f, 2f)
    private var fakePlayer: EntityOtherPlayerMP? = null
    private var flagTPState = 0
    private var playerPos = Vec3(.0,.0,.0)
    override val tag: String
        get() = mode.get()
    override fun onEnable() {
        when(mode.get()) {
            "Flag" -> {
                flagTPState = if (!mc.playerController.isSpectator){
                    ChatUtils.messageWithStart("§7[§cTP§7] §cJump In To Void!")
                    0
                }else 1
            }
            "AAC" -> {
                val thePlayer = mc.thePlayer ?: return
                playerPos = Vec3(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ)
                val playerMP = EntityOtherPlayerMP(mc.theWorld!!, thePlayer.gameProfile)
                playerMP.rotationYawHead = thePlayer.rotationYawHead;
                playerMP.renderYawOffset = thePlayer.renderYawOffset;
                playerMP.rotationYawHead = thePlayer.rotationYawHead
                playerMP.copyLocationAndAnglesFrom(thePlayer)
                mc.theWorld!!.addEntityToWorld(-1000, playerMP)
                //thePlayer.noClip = true
                fakePlayer = playerMP
            }
        }
    }
    override fun onDisable() {
        flagTPState = 0
        when(mode.get()) {
            "AAC" -> {
                val thePlayer = mc.thePlayer
                if (thePlayer == null || fakePlayer == null)
                    return
                //thePlayer.setPositionAndRotation(playerPos.xCoord, playerPos.yCoord, playerPos.zCoord, thePlayer.rotationYaw, thePlayer.rotationPitch)
                mc.theWorld!!.removeEntityFromWorld(fakePlayer!!.entityId)
                fakePlayer = null
                thePlayer.motionX = 0.0
                thePlayer.motionY = 0.0
                thePlayer.motionZ = 0.0

                //Do teleport
                val packets = (mc.thePlayer.getDistance(playerPos.xCoord,playerPos.yCoord,playerPos.zCoord).toInt() / 10) + 1
                val packetY = arrayOf(1.1,1.1,1.2,1.2,.8,.8,.4,.0,.0,1.1,1.1)
                repeat(11){
                    mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(playerPos.xCoord,playerPos.yCoord+packetY[it],playerPos.zCoord,true))
                }

                val xV = ((thePlayer.posX - playerPos.xCoord)) / packets.toDouble()
                val yV = ((thePlayer.posY - playerPos.yCoord)) / packets.toDouble()
                val zV = ((thePlayer.posZ - playerPos.zCoord)) / packets.toDouble()
                repeat(packets){
                    mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(playerPos.xCoord+xV*(it+1),playerPos.yCoord+yV*(it+1),playerPos.zCoord+zV*(it+1),true))
                }
                mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(thePlayer.posX,thePlayer.posY-1,thePlayer.posZ,true))
                mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(playerPos.xCoord,playerPos.yCoord,playerPos.zCoord,true))
                Thread({
                    sleep(50L)
                    repeat(2) {
                        mc.netHandler.addToSendQueue(
                            C03PacketPlayer.C04PacketPlayerPosition(
                                thePlayer.posX,
                                thePlayer.posY,
                                thePlayer.posZ,
                                true
                            )
                        )
                    }
                    sleep(50L)
                    mc.netHandler.addToSendQueue(
                        C03PacketPlayer.C04PacketPlayerPosition(
                            thePlayer.posX + .09,
                            thePlayer.posY,
                            thePlayer.posZ,
                            true
                        )
                    )
                },"Teleport-SendPacket").start()
            }
        }
    }
    @EventTarget fun onUpdate(event: UpdateEvent){
        when(mode.get()){
            "Flag" -> {
                if (flagTPState >= 2){
                    mc.thePlayer.setPosition(mc.thePlayer.posX,mc.thePlayer.posY+9.25,mc.thePlayer.posZ)
                    mc.thePlayer.motionY=1.0
                    if (flagTPState > keepTick.get()+2) this.toggle()
                    flagTPState += 1
                }
                if (flagTPState == 1 && !mc.playerController.isSpectator) flagTPState = 2
                if (flagTPState == 0 && mc.playerController.isSpectator) flagTPState = 1
                if (autoBedFind.get() && mc.playerController.isSpectator) {
                    val teams = KevinClient.moduleManager.getModule("Teams") as Teams
                    val yRange = bedFindRange.get() downTo -bedFindRange.get()+1
                    val xzRange = -bedFindRange.get()..bedFindRange.get()
                    var bedPos:BlockPos? = null
                     l@ for (x in xzRange) {
                         for (z in xzRange) {
                             for (y in yRange){
                                 val pos = BlockPos(mc.thePlayer.posX.toInt()+x, mc.thePlayer.posY.toInt()+y, mc.thePlayer.posZ.toInt()+z)
                                 if (BlockUtils.getBlock(pos) == Blocks.bed&&(!teams.getToggle()||!teams.bedCheckValue.get()||pos !in teams.teamBed)) {
                                     bedPos = pos
                                     break@l
                                 }
                             }
                         }
                     }
                    if (bedPos!=null){
                        mc.thePlayer.setPositionAndUpdate(bedPos.x.toDouble()+.5,bedPos.y-1.toDouble(),bedPos.z.toDouble()+.5)
                    }
                }
            }
            "AAC" -> {
                val thePlayer = mc.thePlayer!!
                //thePlayer.noClip = true
                thePlayer.fallDistance = 0.0f
                val value = aacFlySpeedValue.get()
                thePlayer.motionY = 0.0
                thePlayer.motionX = 0.0
                thePlayer.motionZ = 0.0
                if (mc.gameSettings.keyBindJump.isKeyDown) thePlayer.motionY += value
                if (mc.gameSettings.keyBindSneak.isKeyDown) thePlayer.motionY -= value
                MovementUtils.strafe(value)
            }
        }
    }
    @EventTarget fun onPacket(event: PacketEvent) {
        when(mode.get()){
            "AAC" -> {
                val packet = event.packet
                if (packet is C03PacketPlayer || packet is C0BPacketEntityAction || packet is C07PacketPlayerDigging || packet is C0APacketAnimation) event.cancelEvent()
            }
        }
    }
}